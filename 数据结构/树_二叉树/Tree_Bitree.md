# 树和二叉树

## 概念
- **节点的度**：节点拥有的子树个数  
- **树的度**：树中节点的度的最大值  
- **有序树和无序树**：树中节点的各子树从左到右是有序的，称为有序树；否则称为无序树  

## 性质
1. 节点数 = 度之和 + 1  
2. **叶节点公式**：  
   $$n_0 = n_2 + 2n_3 + 3n_4 + \cdots + (m-1)n_m + 1$$  
   > 推导过程：  
   > 1. $N = n_0 + n_1 + n_2 + \cdots + n_m$  
   > 2. $N = \text{分支数} + 1$  
   > 3. $\text{分支数} = n_1 + 2n_2 + 3n_3 + \cdots + m n_m$  

3. **高度为h的m叉树**：  
   - 最多节点数：  
   $$
   \frac{m^h - 1}{m-1}
   $$  
   （首项为1公比为m的等比数列求和）

4. **具有n个节点的m叉树**：  
   - 最大高度：$n$（退化为链表）  
   - 最小高度：$\lceil \log_m [n(m-1) + 1] \rceil$  

5. **完全二叉树**：  
   - 定义：除了最后一层外，其他层都是满的，且最后一层从左到右连续  
   - 高度k与节点数n关系：  
     $$
     2^{k-1} \leq n < 2^k
     $$  
   - 性质：  
     - 有右子树必有左子树  
     - 度为一的节点数量为0或1  
     - 深度计算：$\lfloor \log_2 n \rfloor + 1$  
     - 节点编号关系：  
       - 父节点：$\lfloor i/2 \rfloor$  
       - 左孩子：$2i$  
       - 右孩子：$2i+1$  

6. **满二叉树**：所有层都完全填满  
7. **线索二叉树**：将空指针改为指向前驱/后继的指针（左前驱，右后继）  

## 哈夫曼树（Huffman Tree）
### 基本概念
1. **定义**：带权路径长度（WPL）最小的二叉树（最优二叉树）  
2. **带权路径长度（WPL）**：  
   $\text{WPL} = \sum (\text{叶节点权值} \times \text{路径长度})$  
   > 路径长度 = 根节点到该节点的边数

### 构造算法
1. 将每个权值视为单节点树  
2. 选择两棵根权值最小的树合并  
3. 新树根权值 = 子树根权值之和  
4. 重复步骤2-3，直至合成一棵树  

### 特性
1. 不存在度为1的节点（只有0度或2度节点）  
2. 叶子节点数 = 非叶子节点数 + 1  
3. 权值越大离根越近  
4. 同权值组的哈夫曼树不唯一（WPL相同）  

### 应用
- **哈夫曼编码**：  
  - 频率高的字符用短编码  
  - 频率低的字符用长编码  
  - 满足前缀编码特性（无二义性）  

## 并查集（Union-Find Set）
### 核心概念
1. **功能**：处理不相交集合的动态合并与查询  
2. **核心操作**：  
   - `find(x)`：查找x的根节点（集合代表）  
   - `union(x, y)`：合并x和y所在集合  

### 实现方式
```c
int parent[N];  // 父节点数组

// 初始化：每个元素自成集合
void init(int n) {
    for (int i = 0; i < n; i++)
        parent[i] = i;
}

// 查找（带路径压缩）
int find(int x) {
    if (parent[x] != x)
        parent[x] = find(parent[x]);  // 路径压缩
    return parent[x];
}

// 合并
void union(int x, int y) {
    int rx = find(x), ry = find(y);
    if (rx != ry) parent[ry] = rx;  // 合并
}
```
### 性能优化
1. **按秩合并**：小树合并到大树（需额外维护rank[]数组）  
```c
int rank[N];  // 树高

// 合并
void union(int x, int y) {
    int rx = find(x), ry = find(y);
    if (rx != ry) {
        if (rank[rx] < rank[ry])
            parent[rx] = ry;
        else if (rank[rx] > rank[ry])
            parent[ry] = rx;
        else {
            parent[rx] = ry;
            rank[ry]++;
        }
    }
}
```
2. **路径压缩**：find时扁平化路径（时间复杂度近O(1)）
```c
// 查找（带路径压缩）
int find(int x) {
    if (parent[x] != x)
        parent[x] = find(parent[x]);  // 路径压缩
    return parent[x];
}
```